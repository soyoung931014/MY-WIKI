# 🎟 Today
또 왔다 또 왔어.. 알았던걸 까먹고 이해했던것이 혼동스러워서 뭐가뭔지 헷갈리기 시작 하는 단계... 어제 배웠던 세션은 이해를 곧 잘했으면서(확실하니?) JWT도 이해 잘해 나가다 막판에 이게 뭐람?.. 헷갈리기 시작한다. accessToken은 왜 여기 들어가는건지,, refreshToken은 또 왜 여기 있으시죠? 싶다. 근데 그것보다 리액트를 다 잊어먹은걸.. 스테이트프롭스가 클래스 객체에 담기면 어떻게 사용을 해줘야하는거죠?... 클라이언트가 내 발목을 잡을건 알고있었지만 오늘은 예상치 못했었는데..! 보구 자야겠다. 다음 주 정도면 이 시기가 지나갔음 좋겠다

오늘배운것
-JWT

# 🧠 JWT


> **세션 기반 인증**은 **서버(혹은DB)**에 유저 정보를 담은 인증 방식이었다. 
매번 유저가 민감한 정보를 서버에다 요청하면 서버는 가지고 있는 세션값과 일치하는지를 매번 확인해야만 한다.때문에 세션을 이용하면 매 요청마다 데이터베이스를 살펴보아야하므로 매번 데이터베이스를 사용하는게 부담이다. 때문에 이에 대한 부담을 덜어내기위한 방법 JWT(JSON Web Token)에 대해 알아보겠다.
![](https://images.velog.io/images/soyoungdl/post/c2edcf1a-f095-4c43-a954-73ef27d70499/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-11-23%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2010.40.07.png)



## 👊 JWT
>- 토큰 인증 방식 중 하나
>- Json Web Token의 약자
- **Json포맷**으로 사용자에 대한 속성을 저장하는 웹 토큰
>-  **클라이언트**에서 인증 정보 보관하기



토큰저장방식 = 클라이언트에서 인증정보를 가지고 있는.  클라이언트가 일종의 마패를 가지고있는 느낌. 

Q.  XSS CSRF등의 공격에 노출되기 쉬우므로  민감한 정보는 가질 수 없다 근데 클라이언트에 저장한다고??
![](https://images.velog.io/images/soyoungdl/post/657a8b33-6291-44b8-8a5c-0d9ba84e061f/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-11-23%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2010.43.30.png)


엥?? 토큰을 클라이언트에 저장한다고? 그건 너무 위험하잖아!
토큰은 유저 정보를 암호화한 상태로 담을 수 있고, 암호화 했기 때문에 클라이언트에 담을 수 있다.

## 👊 JWT 구조
![](https://images.velog.io/images/soyoungdl/post/512696fa-5412-478a-b2bb-4bcee8b284f9/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-11-23%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2010.47.06.png)
>1. Header
- Header는 이것이 어떤 종류의 토큰인지(지금의 경우엔 JWT), 어떤 알고리즘으로 sign할지가 적혀있다.JSON 객체를 base64방식으로 인코딩하면 JWT의 첫 번째 부분이 완성된다.
>2. Payload
- Payload에는 정보가 담겨있다. 어떤 정보에 접근 가능한지에 대한 권한을 담을 수도 있고, 사용자의 유저 이름 등 필요한 데이터는 이곳에 남아 Sign시킨다. 암호화가 되는 정보이지만 민감한 정보는 담지 말자. 첫 번째 부분과 마찬가지로, 위 JSON 객체를 base 64로 인코딩하면 JWT의 두 번쨰 블록이 완성된다.
>3. Signature
- base64로 인코딩된 첫 번째, 그리고 두 번째 부분이 완성되었다면, 원하는 비밀 키(암호화에 추가할 **salt**)를 사용하여 암호화한다.base64 인코딩을 한 값은 누구나 쉽게 디코딩할 수 있지만, 서버에서 사용하고 있는 비밀키를 보유한 게 아니라면 해독해 내는데 엄청난 시간과 노력이 들어간다.
예를 들어, 만약 HMAC SHA256 알고리즘(암호화 방법 중 하나)을 사용한다면 signature는 아래와 같은 방식으로 생성됩니다.
![](https://images.velog.io/images/soyoungdl/post/c6a67b84-689a-4407-b5fb-503726041bad/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-11-23%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2010.49.38.png)


![](https://images.velog.io/images/soyoungdl/post/7f27896e-da99-4460-9ec3-9abfe6cb91bc/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-11-23%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2010.50.00.png)

JWT 토큰은 로컬스토리지, 쿠키, 리액트 스테이트,, 등등 다양한곳에 저장가능하다.



## 👊 JWT의 종류
> 1. Acess Token
> 2. Refresh Token

- **Acess Token은 보호된 정보들(유저의 이메일, 연락처, 사진 등)에 접근할 수 있는 권한 부여에 사용된다.** 클라이언트가 처음 인증을 받게 될 떄 (로그인시), access, refresh token 두 가지를 다 받지만, 실제로 권한을 얻는데 사용하는 토큰은 access token이다.

그렇다면 access token만 주면 되는거 아닌가?

- 맞다! 권한을 부여받는 데엔 access token만 가지고 있으면 된다. 하지만 access token을 만약 악의적인 유저가 얻어냈다면 어떻게 될까? 이 악의적인 유저는 자신이 00유저인것 마냥 서버에 여러가지 요청을 보낼 수 있다. (만약 이문제가 돈이라면 문제가 커지겠지..) 그렇기 때문에 **access token에는 비교적 짧은 유효기간을 주어 탈취되더라도 오랫동안 사용할 수 없도록 하는것이 좋다.**

- Access token의 유효기간이 만료된다면 refresh token을 사용하여 새로운 access token을 발급받는다. 이때 유저는 다시 로그인할 필요가 없다.

refresh token도 탈취당한다면?

- 유효기간이 긴 refresh token마저 악의적인 유저가 얻어낸다면 큰 문제가 될 것이다. 상당히 오랜기간 동안 access token이 만료되면  다시 발급받으며 유저에게 피해를 입힐 수 있기 때문이다. 그렇기 때문에 **유저의 편의보다 정보를 지키는것이 더 중요한 웹사이트들은 refresh token을 사용하지 않는 곳이 많다.** 


## 👊 JWT 장점

![](https://images.velog.io/images/soyoungdl/post/08319b76-1733-4188-b1cc-3a6457332599/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-11-23%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2010.51.26.png)


> 출처
> - 
